#!/usr/bin/env bash
#
# Script name: kyosinstall-auto
# Description: Fully automated KyOS installer with default options and no encryption
# Dependencies: 
# GitLab: https://www.gitlab.com/kyos/kyosinstall/
# License: https://www.gitlab.com/kyos/kyosinstall/
# Contributors: Derek Taylor

# Set with the flags "-e", "-u","-o pipefail" cause the script to fail
# if certain things happen, which is a good thing.  Otherwise, we can
# get hidden bugs that are hard to discover.
set -euo pipefail

# Disable bash job control and history to avoid console issues
set +m
set +H

# Function to handle script errors
error_handler() {
    local line_no=$1
    local bash_lineno=$2
    local last_command=$3
    local code=$4
    
    echo ""
    echo "=============================================="
    echo "ERROR: Installation script failed!"
    echo "=============================================="
    echo "Line: $line_no"
    echo "Bash Line: $bash_lineno" 
    echo "Command: $last_command"
    echo "Exit Code: $code"
    echo "=============================================="
    echo ""
    echo "Please check the error above and try again."
    echo "If the problem persists, please report this issue."
    echo ""
    exit $code
}

# Set up error handling
trap 'error_handler ${LINENO} $BASH_LINENO "$BASH_COMMAND" $?' ERR

# Check if running as root, if not, re-run with sudo
if [[ $EUID -ne 0 ]]; then
    echo "This installer requires root privileges. Re-running with sudo..."
    echo "You may be prompted for your password."
    exec sudo -E "$0" "$@"
fi

# Double-check we're actually running as root now
if [[ $EUID -ne 0 ]]; then
    echo "ERROR: Failed to obtain root privileges. Please run with sudo:"
    echo "sudo $0 $*"
    exit 1
fi

# Let's clear the tty when starting script
clear

# Debug information
echo "=============================================="
echo "KyOS Automated Installation System"
echo "=============================================="
echo "Debug Information:"
echo "- Script: $0"
echo "- Arguments: $*"
echo "- Current user: $(whoami)"
echo "- Effective UID: $EUID"
echo "- Running as root: $([ $EUID -eq 0 ] && echo 'YES' || echo 'NO')"
echo "- Environment: $([ -d /run/archiso ] && echo 'Live ISO' || echo 'Installed System')"
echo "- Working directory: $(pwd)"
echo "=============================================="
echo

# Verify we're in the correct environment
if [[ ! -d /run/archiso ]]; then
    echo "WARNING: This installer is designed to run from the KyOS live environment."
    echo "Please boot from the KyOS ISO and run the installer from there."
    echo ""
    read -p "Continue anyway? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Installation cancelled."
        exit 1
    fi
fi

# --- Logging Configuration ---

# Create log directory and setup logging
LOG_DIR="/var/log/kyos-install"
LOG_FILE="$LOG_DIR/kyosinstall-auto-$(date +%Y%m%d-%H%M%S).log"
ERROR_LOG="$LOG_DIR/kyosinstall-auto-errors-$(date +%Y%m%d-%H%M%S).log"

# Create log directory if it doesn't exist
mkdir -p "$LOG_DIR" 2>/dev/null || {
    # If /var/log is not writable, use /tmp
    LOG_DIR="/tmp/kyos-install"
    LOG_FILE="$LOG_DIR/kyosinstall-auto-$(date +%Y%m%d-%H%M%S).log"
    ERROR_LOG="$LOG_DIR/kyosinstall-auto-errors-$(date +%Y%m%d-%H%M%S).log"
    mkdir -p "$LOG_DIR"
}

# Function to log messages with timestamp
log_message() {
    local level="$1"
    shift
    local message="$*"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$timestamp] [$level] $message" | tee -a "$LOG_FILE"
}

# Function to log errors
log_error() {
    local message="$*"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$timestamp] [ERROR] $message" | tee -a "$LOG_FILE" | tee -a "$ERROR_LOG"
}

# Function to log command execution
log_command() {
    local cmd="$*"
    log_message "COMMAND" "Executing: $cmd"
    
    # Execute command and capture both stdout and stderr
    {
        eval "$cmd" 2>&1
        local exit_code=$?
        if [ $exit_code -ne 0 ]; then
            log_error "Command failed with exit code $exit_code: $cmd"
        else
            log_message "SUCCESS" "Command completed successfully: $cmd"
        fi
        return $exit_code
    } | tee -a "$LOG_FILE"
}

# Function to create final installation report
create_install_report() {
    local report_file="$LOG_DIR/kyosinstall-auto-report-$(date +%Y%m%d-%H%M%S).txt"
    
    cat > "$report_file" << EOF
================================================================================
                     KyOS Automated Installation Report
================================================================================
Installation Date: $(date)
Installation Type: Automated (kyosinstall-auto)

SYSTEM CONFIGURATION:
- Hostname: kyos-pc
- Username: kyos
- Timezone: America/New_York
- Locale: en_US.UTF-8
- Keyboard Layout: us

DISK CONFIGURATION:
- Target Device: Auto-detected
- UEFI Mode: Auto-detected
- Encryption: Disabled
- Swap: ZRAM

ADDITIONAL OPTIONS:
- BlackArch Support: ${blackarch_enabled:-false}
- NVIDIA Support: ${nvidia_enabled:-false}
- Filesystem: btrfs
- Kernel: linux

LOG FILES:
- Main Log: $LOG_FILE
- Error Log: $ERROR_LOG
- This Report: $report_file

INSTALLATION STATUS:
$(if [ -f "$ERROR_LOG" ] && [ -s "$ERROR_LOG" ]; then
    echo "âš  COMPLETED WITH ERRORS - Please check error log for details"
    echo ""
    echo "ERRORS ENCOUNTERED:"
    tail -20 "$ERROR_LOG" | sed 's/^/  /'
else
    echo "âœ“ COMPLETED SUCCESSFULLY"
fi)

================================================================================
End of Report
================================================================================
EOF

    # Copy logs to installed system if possible
    if [ -d "/mnt/var/log" ]; then
        mkdir -p "/mnt/var/log/kyos-install" 2>/dev/null
        cp "$LOG_FILE" "$ERROR_LOG" "$report_file" "/mnt/var/log/kyos-install/" 2>/dev/null && \
            log_message "INFO" "Logs copied to installed system: /var/log/kyos-install/"
    fi
    
    echo "$report_file"
}

# Set up error handling and logging
set -E
trap 'log_error "Script failed at line $LINENO: $BASH_COMMAND"; create_install_report; exit 1' ERR

# Initialize logging
log_message "INFO" "KyOS Automated Installation System starting"
log_message "INFO" "Log file: $LOG_FILE"
log_message "INFO" "Error log: $ERROR_LOG"
log_message "INFO" "PID: $$, User: $(whoami), PWD: $(pwd)"

echo "=============================================="
echo "KyOS AUTOMATED INSTALLER"
echo "=============================================="
echo "This will install KyOS with the following defaults:"
echo "- Locale: en_US.UTF-8"
echo "- Keyboard: us"
echo "- Timezone: America/New_York"
echo "- Hostname: kyos-pc"
echo "- Username: kyos"
echo "- Password: kyos123"
echo "- Root password: root123"
echo "- Filesystem: btrfs"
echo "- Encryption: NO"
echo "- Kernel: linux"
echo "- Install KyOS desktop: YES"
echo "- BlackArch repository: NO (default)"
echo "- NVIDIA support: NO (default)"
echo "- Swap: ZRAM (default)"
echo "=============================================="
echo

# Check firmware type but don't exit
if [ -d "/sys/firmware/efi/" ]; then
    firmware_type="UEFI"
    echo "UEFI firmware detected - installation will use UEFI mode"
else
    firmware_type="BIOS"
    echo "Legacy BIOS firmware detected - installation will use BIOS mode"
fi
echo

BOLD='\e[1m'
GREEN='\e[92m'
RED='\e[91m'
YELLOW='\e[93m'
RESET='\e[0m'

print_info () {
    echo -ne "${BOLD}${YELLOW}$1${RESET}\n"
}

print_choice () {
    echo -ne "${BOLD}${GREEN}>> $1${RESET}\n\n"
}

# Enhanced package installation function with better visibility
install_package_with_progress() {
    local package="$1"
    local current="$2"
    local total="$3"
    local description="${4:-$package}"
    
    echo ""
    echo "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
    echo "â”‚ [$current/$total] Installing: $description"
    echo "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
    echo ""
    
    # Install with verbose output
    if arch-chroot /mnt pacman -S --noconfirm --needed "$package" 2>&1 | while IFS= read -r line; do
        # Add visual indicators for different types of output
        if [[ "$line" =~ ^.*error.*$ ]] || [[ "$line" =~ ^.*failed.*$ ]]; then
            echo "  âŒ $line"
        elif [[ "$line" =~ ^.*warning.*$ ]]; then
            echo "  âš ï¸  $line" 
        elif [[ "$line" =~ ^.*installing.*$ ]] || [[ "$line" =~ ^.*upgrading.*$ ]]; then
            echo "  ðŸ“¦ $line"
        elif [[ "$line" =~ ^.*checking.*$ ]]; then
            echo "  ðŸ” $line"
        elif [[ "$line" =~ ^.*loading.*$ ]]; then
            echo "  ðŸ“¥ $line"
        elif [[ "$line" =~ ^.*resolving.*$ ]]; then
            echo "  ðŸ§© $line"
        else
            echo "  ðŸ’¾ $line"
        fi
        echo "$line" >> "$LOG_FILE" 2>/dev/null || true
    done; then
        echo ""
        echo "  âœ… Successfully installed: $package"
        echo ""
        return 0
    else
        echo ""
        echo "  âŒ Failed to install: $package"
        echo ""
        return 1
    fi
}

vm_check () {
    hypervisor=$(systemd-detect-virt 2>/dev/null || echo "none")
    case $hypervisor in
        kvm )       echo "â†’ Installing KVM guest agent..."
                    pacstrap /mnt qemu-guest-agent 2>&1 | while IFS= read -r line; do
                        echo "  $line"
                    done &>/dev/null
                    systemctl enable qemu-guest-agent --root=/mnt &>/dev/null
                    echo "âœ“ KVM guest tools configured"
                    ;;
        vmware  )   echo "â†’ Installing VMware tools..."
                    pacstrap /mnt open-vm-tools 2>&1 | while IFS= read -r line; do
                        echo "  $line"
                    done &>/dev/null
                    systemctl enable vmtoolsd --root=/mnt &>/dev/null
                    systemctl enable vmware-vmblock-fuse --root=/mnt &>/dev/null
                    echo "âœ“ VMware tools configured"
                    ;;
        oracle )    echo "â†’ Installing VirtualBox guest utilities..."
                    pacstrap /mnt virtualbox-guest-utils 2>&1 | while IFS= read -r line; do
                        echo "  $line"
                    done &>/dev/null
                    systemctl enable vboxservice --root=/mnt &>/dev/null
                    echo "âœ“ VirtualBox guest utilities configured"
                    ;;
        microsoft ) echo "â†’ Installing Hyper-V tools..."
                    pacstrap /mnt hyperv 2>&1 | while IFS= read -r line; do
                        echo "  $line"
                    done &>/dev/null
                    systemctl enable hv_fcopy_daemon --root=/mnt &>/dev/null
                    systemctl enable hv_kvp_daemon --root=/mnt &>/dev/null
                    systemctl enable hv_vss_daemon --root=/mnt &>/dev/null
                    echo "âœ“ Hyper-V tools configured"
                    ;;
    esac
}

detect_graphics() {
    print_info "Detecting graphics hardware..."
    
    # Check for NVIDIA GPU
    if lspci | grep -i nvidia >/dev/null 2>&1; then
        local nvidia_card=$(lspci | grep -i nvidia | head -1 | cut -d: -f3- | sed 's/^ *//')
        print_info "NVIDIA GPU detected: $nvidia_card"
        return 0
    fi
    
    # Check for AMD GPU
    if lspci | grep -i amd | grep -i vga >/dev/null 2>&1; then
        local amd_card=$(lspci | grep -i amd | grep -i vga | head -1 | cut -d: -f3- | sed 's/^ *//')
        print_info "AMD GPU detected: $amd_card"
        return 1
    fi
    
    # Check for Intel integrated graphics
    if lspci | grep -i intel | grep -i vga >/dev/null 2>&1; then
        local intel_card=$(lspci | grep -i intel | grep -i vga | head -1 | cut -d: -f3- | sed 's/^ *//')
        print_info "Intel integrated graphics detected: $intel_card"
        return 2
    fi
    
    # Fallback - check for any VGA controller
    if lspci | grep -i vga >/dev/null 2>&1; then
        local generic_card=$(lspci | grep -i vga | head -1 | cut -d: -f3- | sed 's/^ *//')
        print_info "Graphics controller detected: $generic_card"
        return 3
    fi
    
    print_info "No graphics hardware detected (running in VM or headless?)"
    return 4
}

install_blackarch() {
    print_info "Setting up BlackArch repository..."
    
    # Method 1: Try the official BlackArch bootstrap script
    print_info "Attempting BlackArch bootstrap installation..."
    if arch-chroot /mnt /bin/bash -c "
        # Download and run the official BlackArch bootstrap
        curl -O https://blackarch.org/strap.sh
        chmod +x strap.sh
        ./strap.sh 2>/dev/null || exit 1
        # Update package databases
        pacman -Syy --noconfirm
    "; then
        print_info "BlackArch repository setup completed successfully!"
        print_info "BlackArch tools can now be installed with: pacman -S <package-name>"
        print_info "List available tools with: pacman -Ss blackarch"
        return 0
    fi
    
    print_info "Bootstrap method failed, trying manual setup..."
    
    # Method 2: Manual setup as fallback
    # Create temporary directory for BlackArch setup
    local tmp_dir="/tmp/blackarch_strap"
    mkdir -p "$tmp_dir"
    cd "$tmp_dir" || return 1
    
    # Try multiple sources for the keyring
    print_info "Downloading BlackArch keyring..."
    local keyring_downloaded=false
    
    # Try different keyring sources
    for url in \
        "https://www.blackarch.org/keyring/blackarch-keyring.pkg.tar.zst" \
        "https://mirror.f4st.host/archlinux/blackarch/blackarch/os/x86_64/blackarch-keyring-20140118-1-any.pkg.tar.xz" \
        "https://blackarch.org/keyring/blackarch-keyring.pkg.tar.xz"
    do
        if curl -s -f -L -o blackarch-keyring.pkg.tar.* "$url"; then
            keyring_downloaded=true
            break
        fi
    done
    
    if [[ "$keyring_downloaded" == "false" ]]; then
        print_info "Failed to download BlackArch keyring from all sources."
        print_info "Adding BlackArch repository without keyring (less secure)..."
        
        # Fallback: Add repository without keyring verification
        arch-chroot /mnt /bin/bash <<-EOF
            # Add BlackArch repository with SigLevel = Never (less secure but works)
            cat >> /etc/pacman.conf << 'REPO_EOF'

[blackarch]
SigLevel = Never
Server = https://www.blackarch.org/blackarch/\$repo/os/\$arch
Server = https://mirror.f4st.host/archlinux/blackarch/\$repo/os/\$arch
REPO_EOF

            # Update package databases
            pacman -Syy --noconfirm || true
EOF
        rm -rf "$tmp_dir"
        print_info "BlackArch repository added (without signature verification)."
        print_info "You can now install BlackArch tools manually with: pacman -S <tool-name>"
        return 0
    fi
    
    # Install keyring in chroot
    print_info "Installing BlackArch keyring..."
    if ! arch-chroot /mnt /bin/bash <<-EOF
        # Copy keyring to chroot
        cp "$tmp_dir"/blackarch-keyring.pkg.tar.* /tmp/
        
        # Install the keyring
        pacman --config /dev/null --noconfirm -U /tmp/blackarch-keyring.pkg.tar.* || exit 1
        
        # Initialize pacman keyring if needed
        pacman-key --init || true
        pacman-key --populate archlinux || true
        pacman-key --populate blackarch || true
EOF
    then
        print_info "Keyring installation failed, falling back to unsigned repository..."
        # Use the fallback method
        arch-chroot /mnt /bin/bash <<-EOF
            cat >> /etc/pacman.conf << 'REPO_EOF'

[blackarch]
SigLevel = Never
Server = https://www.blackarch.org/blackarch/\$repo/os/\$arch
REPO_EOF
            pacman -Syy --noconfirm || true
EOF
        rm -rf "$tmp_dir"
        print_info "BlackArch repository added (fallback mode)."
        print_info "You can now install BlackArch tools manually with: pacman -S <tool-name>"
        return 0
    fi
    
    # Add BlackArch repository to pacman.conf
    print_info "Configuring BlackArch repository..."
    arch-chroot /mnt /bin/bash <<-EOF
        # Remove existing BlackArch entries if any
        sed -i '/\[blackarch\]/,/^$/d' /etc/pacman.conf
        
        # Add BlackArch repository
        cat >> /etc/pacman.conf << 'REPO_EOF'

[blackarch]
Server = https://www.blackarch.org/blackarch/\$repo/os/\$arch
Server = https://mirror.f4st.host/archlinux/blackarch/\$repo/os/\$arch
REPO_EOF

        # Update package databases
        pacman -Syy --noconfirm || true
EOF
    
    # Cleanup
    rm -rf "$tmp_dir"
    print_info "BlackArch repository setup completed!"
    print_info "The BlackArch repository is now available with 2600+ security tools."
    print_info "Install tools individually with: pacman -S <tool-name>"
    print_info "Browse available tools with: pacman -Ss blackarch"
    print_info "Popular tools: nmap, metasploit, burpsuite, sqlmap, aircrack-ng"
}

install_nvidia_drivers() {
    print_info "Installing NVIDIA drivers and utilities..."
    
    # Detect kernel type for proper DKMS driver selection
    local kernel_pkg=""
    case "$kernel" in
        "linux")
            kernel_pkg="nvidia-dkms"
            ;;
        "linux-lts")
            kernel_pkg="nvidia-dkms"
            ;;
        "linux-zen")
            kernel_pkg="nvidia-dkms"
            ;;
        *)
            kernel_pkg="nvidia-dkms"
            ;;
    esac
    
    # Install NVIDIA drivers and utilities
    arch-chroot /mnt /bin/bash -e <<-EOF
        # Install NVIDIA drivers
        pacman -S --noconfirm $kernel_pkg nvidia-utils nvidia-settings
        
        # Install additional NVIDIA utilities
        pacman -S --noconfirm opencl-nvidia libva-nvidia-driver
        
        # Install envycontrol via pacman (if available)
        pacman -S --noconfirm envycontrol || echo "envycontrol not available in repos, skipping"
        
        # Add nvidia modules to mkinitcpio.conf
        sed -i 's/^MODULES=(\(.*\))/MODULES=(\1 nvidia nvidia_modeset nvidia_uvm nvidia_drm)/' /etc/mkinitcpio.conf
        
        # Add nvidia-drm.modeset=1 to kernel parameters
        if [ -f /etc/default/grub ]; then
            sed -i 's/GRUB_CMDLINE_LINUX_DEFAULT="\(.*\)"/GRUB_CMDLINE_LINUX_DEFAULT="\1 nvidia-drm.modeset=1"/' /etc/default/grub
        fi
        
        # Create nvidia hook for package manager
        mkdir -p /etc/pacman.d/hooks
        cat > /etc/pacman.d/hooks/nvidia.hook << HOOK_EOF
[Trigger]
Operation=Install
Operation=Upgrade
Operation=Remove
Type=Package
Target=nvidia-dkms
Target=linux

[Action]
Description=Update NVIDIA module in initcpio
Depends=mkinitcpio
When=PostTransaction
NeedsTargets
Exec=/bin/sh -c 'while read -r trg; do case \$trg in linux*) exit 0; esac; done; /usr/bin/mkinitcpio -P'
HOOK_EOF

        # Regenerate initramfs
        mkinitcpio -P
EOF
    
    print_info "NVIDIA drivers installation completed!"
    print_info "Note: You can use 'envycontrol --switch nvidia' to switch to NVIDIA GPU after reboot."
    print_info "Use 'envycontrol --switch integrated' to switch to integrated graphics."
}

setup_zram() {
    print_info "Setting up ZRAM compressed swap..."
    
    # Install zram-generator
    arch-chroot /mnt pacman -S --noconfirm zram-generator
    
    # Create zram-generator configuration
    arch-chroot /mnt /bin/bash -e <<-EOF
        # Create configuration directory
        mkdir -p /etc/systemd/zram-generator.conf.d
        
        # Create zram configuration
        cat > /etc/systemd/zram-generator.conf << ZRAM_EOF
[zram0]
zram-size = ram / 2
compression-algorithm = zstd
swap-priority = 100
fs-type = swap
ZRAM_EOF
        
        # Enable zram service
        systemctl enable systemd-zram-setup@zram0.service
EOF
    
    print_info "ZRAM swap setup completed!"
    print_info "ZRAM will use up to 50% of your RAM for compressed swap."
}

setup_swap_partition() {
    print_info "Setting up swap partition..."
    
    # Create swap partition (this would need partition table modification)
    # For now, we'll create a swap file instead as it's safer
    print_info "Creating swap file (8GB) instead of partition for safety..."
    
    arch-chroot /mnt /bin/bash -e <<-EOF
        # Create swap file
        fallocate -l 8G /swapfile
        chmod 600 /swapfile
        mkswap /swapfile
        
        # Add to fstab
        echo '/swapfile none swap defaults 0 0' >> /etc/fstab
        
        # Enable swap
        swapon /swapfile
EOF
    
    print_info "Swap file setup completed!"
    print_info "Created 8GB swap file at /swapfile"
}

echo -e "${BOLD}${GREEN}KyOS AUTOMATED INSTALLER${RESET}"
echo -e "${BOLD}       The AUTOMATED installation script for KyOS${RESET}\n"

# Set all default values
locale="en_US.UTF-8"
keymap="us"
timezone="America/New_York"
hostname="kyos-pc"
username="kyos"
userpass="kyos123"
rootpass="root123"
fs_type="btrfs"
encryption="no"
kernel="linux"
kyos_desktop="yes"
blackarch_support="no"
nvidia_support="no"
swap_type="zram"

# Check for TUI configuration file
if [[ -n "${CONFIG_FILE:-}" && -f "${CONFIG_FILE:-}" ]]; then
    print_info "Loading configuration from: $CONFIG_FILE"
    source "$CONFIG_FILE"
    # Map TUI variables to installer variables
    [[ -n "${TIMEZONE:-}" ]] && timezone="$TIMEZONE"
    [[ -n "${KEYMAP:-}" ]] && keymap="$KEYMAP"
    [[ -n "${LOCALE:-}" ]] && locale="$LOCALE"
    [[ -n "${USERNAME:-}" ]] && username="$USERNAME"
    [[ -n "${PASSWORD:-}" ]] && userpass="$PASSWORD"
    [[ -n "${ROOT_PASSWORD:-}" ]] && rootpass="$ROOT_PASSWORD"
    [[ -n "${HOSTNAME:-}" ]] && hostname="$HOSTNAME"
    [[ -n "${ENCRYPT:-}" ]] && encryption="$ENCRYPT"
    print_info "Configuration loaded successfully."
elif [[ -f "/tmp/kyos-tui-config" ]]; then
    print_info "Loading TUI configuration..."
    source /tmp/kyos-tui-config
    # Map TUI variables to installer variables
    [[ -n "${TIMEZONE:-}" ]] && timezone="$TIMEZONE"
    [[ -n "${KEYMAP:-}" ]] && keymap="$KEYMAP"
    [[ -n "${LOCALE:-}" ]] && locale="$LOCALE"
    [[ -n "${USERNAME:-}" ]] && username="$USERNAME"
    [[ -n "${PASSWORD:-}" ]] && userpass="$PASSWORD"
    [[ -n "${ROOT_PASSWORD:-}" ]] && rootpass="$ROOT_PASSWORD"
    [[ -n "${HOSTNAME:-}" ]] && hostname="$HOSTNAME"
    [[ -n "${ENCRYPT:-}" ]] && encryption="$ENCRYPT"
    [[ -n "${BLACKARCH:-}" ]] && blackarch_support="$BLACKARCH"
    [[ -n "${NVIDIA:-}" ]] && nvidia_support="$NVIDIA"
    [[ -n "${SWAP_TYPE:-}" ]] && swap_type="$SWAP_TYPE"
    print_info "TUI configuration loaded successfully."
fi

print_info "Using configuration:"
echo -e "locale:\t\t${BOLD}${GREEN}$locale${RESET}"
echo -e "keymap:\t\t${BOLD}${GREEN}$keymap${RESET}"
echo -e "timezone:\t${BOLD}${GREEN}$timezone${RESET}"
echo -e "hostname:\t${BOLD}${GREEN}$hostname${RESET}"
echo -e "username:\t${BOLD}${GREEN}$username${RESET}"
echo -e "filesystem:\t${BOLD}${GREEN}$fs_type${RESET}"
echo -e "encryption:\t${BOLD}${GREEN}$encryption${RESET}"
echo -e "kernel:\t\t${BOLD}${GREEN}$kernel${RESET}"
echo -e "kyos_desktop:\t${BOLD}${GREEN}$kyos_desktop${RESET}"
echo -e "blackarch:\t${BOLD}${GREEN}$blackarch_support${RESET}"
echo -e "nvidia:\t\t${BOLD}${GREEN}$nvidia_support${RESET}"
echo -e "swap_type:\t${BOLD}${GREEN}$swap_type${RESET}"
echo

# Auto-select the first available disk
print_info "Detecting available disks:"
lsblk -e 7
mapfile -t disk_array < <(lsblk -dpno NAME | grep -P "/dev/sd|nvme|vd")

if [[ ${#disk_array[@]} -eq 0 ]]; then
    echo "ERROR: No suitable disks found!"
    exit 1
fi

disk="${disk_array[0]}"
print_choice "Auto-selected disk: $disk"

echo
print_info "${RED}WARNING! All data on $disk will be destroyed!${RESET}"
print_info "Starting installation in 10 seconds... (Ctrl+C to cancel)"
for i in {10..1}; do
    echo -n "$i... "
    sleep 1
done
echo
echo

print_choice "Starting automated KyOS installation..."

# Add debug information for VirtualBox troubleshooting
print_info "System Information:"
echo "Hypervisor: $(systemd-detect-virt 2>/dev/null || echo 'none')"
echo "Disk: $disk"
echo "Disk info:"
lsblk "$disk" 2>/dev/null || echo "Could not get disk info"

# VirtualBox-specific warning
if [[ "$(systemd-detect-virt 2>/dev/null)" == "oracle" ]]; then
    echo ""
    echo "NOTE: VirtualBox detected. If installation fails:"
    echo "1. Ensure VM has at least 20GB disk space"
    echo "2. Use SATA controller (not IDE)"
    echo "3. Enable EFI if using UEFI mode"
    echo "4. Disable Hyper-V if on Windows host"
    echo ""
fi
echo

print_info "Reflector grabbing top 20 mirrors sorted by download rate."
echo "This may take a couple of minutes."
reflector --latest 20 --sort rate --save /etc/pacman.d/mirrorlist &>/dev/null || echo "Warning: reflector failed, continuing with existing mirrors"

echo ""
echo "######################################################"
echo "#                                                    #"
echo "#            KYOS INSTALLATION STARTING             #"
echo "#                                                    #"
echo "######################################################"
echo ""
echo "Installation Plan:"
echo "  â†’ Disk: ${disk}"
echo "  â†’ File system: $fs_type"
echo "  â†’ Firmware: $firmware_type"
echo "  â†’ Hostname: $hostname"
echo "  â†’ Username: $username"
echo "  â†’ Desktop: KyOS Qtile"
echo "  â†’ BlackArch: $blackarch_support"
echo "  â†’ NVIDIA: $nvidia_support"
echo "  â†’ Swap: $swap_type"
echo ""
echo "Installation Progress:"
echo "  1. â³ Disk partitioning and formatting"
echo "  2. â³ Base system installation"
echo "  3. â³ Desktop environment installation"
echo "  4. â³ System configuration"
echo "  5. â³ Bootloader installation"
echo "  6. â³ Final setup and cleanup"
echo ""
echo "========================================"
echo "STEP 1: DISK PARTITIONING AND SETUP"
echo "========================================"
print_info "Partitioning the disk: ${disk}"
echo "File system type: $fs_type"
echo "Firmware type: $firmware_type"

# Cleanup any existing partitions and mounts
print_info "Cleaning up existing partitions and mounts on ${disk}..."

# Check if any processes are using the disk
busy_processes=$(lsof "$disk"* 2>/dev/null | grep -v COMMAND || true)
if [[ -n "$busy_processes" ]]; then
    print_info "Warning: Found processes using the disk:"
    echo "$busy_processes"
    print_info "Attempting to kill processes using the disk..."
    lsof -t "$disk"* 2>/dev/null | xargs -r kill -9 2>/dev/null || true
    sleep 2
fi

# Find all partitions on the selected disk
existing_partitions=$(lsblk -lno NAME "${disk}" | grep -v "^$(basename "${disk}")$" | sed "s|^|/dev/|" || true)

if [[ -n "$existing_partitions" ]]; then
    print_info "Found existing partitions to clean up:"
    echo "$existing_partitions"
    
    # Unmount any mounted partitions
    for partition in $existing_partitions; do
        if mountpoint -q "$partition" 2>/dev/null; then
            print_info "Unmounting $partition..."
            umount "$partition" 2>/dev/null || true
        fi
        
        # Check if partition is mounted anywhere else
        mount_points=$(findmnt -rno TARGET "$partition" 2>/dev/null || true)
        if [[ -n "$mount_points" ]]; then
            print_info "Force unmounting $partition from: $mount_points"
            echo "$mount_points" | while read -r mount_point; do
                umount "$mount_point" 2>/dev/null || true
            done
        fi
    done
    
    # Also check for any mounts under /mnt
    mnt_mounts=$(findmnt -rno SOURCE,TARGET | grep "^${disk}" | awk '{print $2}' || true)
    if [[ -n "$mnt_mounts" ]]; then
        print_info "Unmounting installation target mounts..."
        echo "$mnt_mounts" | sort -r | while read -r mount_point; do
            if [[ -n "$mount_point" ]]; then
                print_info "Unmounting $mount_point"
                umount "$mount_point" 2>/dev/null || true
            fi
        done
    fi
    
    # Force unmount /mnt if it exists
    if mountpoint -q /mnt 2>/dev/null; then
        print_info "Force unmounting /mnt..."
        umount -R /mnt 2>/dev/null || true
    fi
    
    sleep 2
fi

# Close any device mapper devices that might be using the disk
dm_devices=$(dmsetup ls | grep -E "${disk##*/}" | awk '{print $1}' 2>/dev/null || true)
if [[ -n "$dm_devices" ]]; then
    print_info "Removing device mapper devices..."
    echo "$dm_devices" | while read -r dm_device; do
        dmsetup remove "$dm_device" 2>/dev/null || true
    done
fi

# Close any LUKS/encrypted volumes
for partition in $existing_partitions; do
    if cryptsetup isLuks "$partition" 2>/dev/null; then
        luks_name=$(basename "$partition")
        if [[ -e "/dev/mapper/$luks_name" ]]; then
            print_info "Closing LUKS volume: $luks_name"
            cryptsetup close "$luks_name" 2>/dev/null || true
        fi
    fi
done

# Deactivate any LVM volume groups on the disk
vgs_on_disk=$(pvs --noheadings -o vg_name "$disk"* 2>/dev/null | sort -u | tr -d ' ' || true)
if [[ -n "$vgs_on_disk" ]]; then
    print_info "Deactivating LVM volume groups..."
    echo "$vgs_on_disk" | while read -r vg; do
        if [[ -n "$vg" ]]; then
            vgchange -an "$vg" 2>/dev/null || true
        fi
    done
fi

# Stop any swap on the disk
if swapon --show=NAME --noheadings | grep -q "${disk}"; then
    print_info "Disabling swap on ${disk}..."
    swapoff "${disk}"* 2>/dev/null || true
fi

# Final sync and wait
sync
sleep 1

if [[ "$firmware_type" = "UEFI" ]]; then
    print_info "Creating GPT partition table for UEFI system"
    # Wipe existing partition table first
    wipefs -af "$disk" || true
    dd if=/dev/zero of="$disk" bs=1M count=10 2>/dev/null || true
    sync
    
    parted -s "$disk" \
        mklabel gpt \
        mkpart ESP fat32 1MiB 1025MiB \
        set 1 esp on \
        mkpart primary 1025MiB 100%
else
    print_info "Creating GPT partition table for BIOS system with BIOS boot partition"
    # Wipe existing partition table first
    wipefs -af "$disk" || true
    dd if=/dev/zero of="$disk" bs=1M count=10 2>/dev/null || true
    sync
    
    parted -s "$disk" \
        mklabel gpt \
        mkpart biosboot 1MiB 2MiB \
        set 1 bios_grub on \
        mkpart ESP fat32 2MiB 1026MiB \
        set 2 esp on \
        mkpart primary 1026MiB 100%
fi

# Force partition table sync (critical for VirtualBox)
print_info "Syncing partition table..."
partprobe "$disk" 2>/dev/null || true
udevadm settle
sync
sleep 3

# Additional partition table sync attempt for stubborn VMs
partprobe "$disk" 2>/dev/null || true
udevadm trigger
udevadm settle

print_info "Checking partition table creation..."
fdisk -l "$disk" || echo "Warning: Could not read partition table"

print_info "Waiting for partition devices to be ready..."
# Wait for partition devices to appear and use direct partition names for better compatibility
if [[ "$firmware_type" = "UEFI" ]]; then
    # For UEFI: partition 1 = ESP, partition 2 = root
    if [[ "$disk" =~ nvme ]]; then
        ESP="${disk}p1"
        ROOT="${disk}p2"
    else
        ESP="${disk}1"
        ROOT="${disk}2"
    fi
else
    # For BIOS: partition 1 = biosboot, partition 2 = ESP, partition 3 = root
    if [[ "$disk" =~ nvme ]]; then
        ESP="${disk}p2"
        ROOT="${disk}p3"
    else
        ESP="${disk}2"
        ROOT="${disk}3"
    fi
fi

# Force kernel to re-read partition table (especially important for VirtualBox)
print_info "Forcing partition table re-read..."
partprobe "$disk" 2>/dev/null || true
udevadm settle
sync

# Wait for devices to exist with enhanced checking
print_info "Waiting for partition devices: $ESP and $ROOT"
for i in {1..60}; do
    # Force udev to settle and check devices
    udevadm settle
    
    if [[ -b "$ESP" && -b "$ROOT" ]]; then
        print_info "Partition devices are ready."
        break
    fi
    
    if [[ $i -eq 30 ]]; then
        print_info "Still waiting... Forcing another partition table re-read..."
        partprobe "$disk" 2>/dev/null || true
        udevadm trigger
        udevadm settle
    fi
    
    echo "Waiting for devices... (attempt $i/60)"
    sleep 1
done

# Final check with detailed error reporting
if [[ ! -b "$ESP" ]]; then
    echo "ERROR: EFI partition $ESP not found!"
    echo "Disk: $disk"
    echo "Available partitions:"
    ls -la "${disk}"* 2>/dev/null || echo "No partitions found"
    echo "Block devices:"
    lsblk "$disk" 2>/dev/null || echo "Cannot list block devices"
    echo "Partition table:"
    fdisk -l "$disk" 2>/dev/null || echo "Cannot read partition table"
    exit 1
fi

if [[ ! -b "$ROOT" ]]; then
    echo "ERROR: Root partition $ROOT not found!"
    echo "Disk: $disk"
    echo "Available partitions:"
    ls -la "${disk}"* 2>/dev/null || echo "No partitions found"
    echo "Block devices:"
    lsblk "$disk" 2>/dev/null || echo "Cannot list block devices"
    echo "Partition table:"
    fdisk -l "$disk" 2>/dev/null || echo "Cannot read partition table"
    exit 1
fi

print_info "Formatting EFI Partition as FAT32."
# Clear any existing filesystem signatures first
wipefs -a "$ESP" 2>/dev/null || true
udevadm settle

# Try formatting with retries for VirtualBox compatibility
for attempt in {1..3}; do
    if mkfs.fat -F 32 "$ESP"; then
        print_info "EFI partition formatted successfully."
        break
    else
        echo "Formatting attempt $attempt failed. Retrying..."
        sleep 2
        udevadm settle
        if [[ $attempt -eq 3 ]]; then
            echo "ERROR: Failed to format EFI partition $ESP after 3 attempts"
            echo "Partition info:"
            lsblk "$ESP" 2>/dev/null || echo "Cannot get partition info"
            exit 1
        fi
    fi
done

# No encryption - format directly
if [[ "$fs_type" = "btrfs" ]]; then
    BTRFS="$ROOT"
    
    print_info "Formatting the BTRFS partition: $BTRFS"
    # Clear any existing filesystem signatures first
    wipefs -a "$BTRFS" 2>/dev/null || true
    udevadm settle
    
    # Try formatting with retries for VirtualBox compatibility
    for attempt in {1..3}; do
        if mkfs.btrfs -f "$BTRFS"; then
            print_info "BTRFS partition formatted successfully."
            break
        else
            echo "BTRFS formatting attempt $attempt failed. Retrying..."
            sleep 2
            udevadm settle
            if [[ $attempt -eq 3 ]]; then
                echo "ERROR: Failed to format BTRFS partition $BTRFS after 3 attempts"
                echo "Partition info:"
                lsblk "$BTRFS" 2>/dev/null || echo "Cannot get partition info"
                exit 1
            fi
        fi
    done
    
    # Mount BTRFS root with retries
    print_info "Mounting BTRFS partition: $BTRFS"
    for attempt in {1..3}; do
        if mount "$BTRFS" /mnt; then
            print_info "BTRFS partition mounted successfully."
            break
        else
            echo "Mount attempt $attempt failed. Retrying..."
            sleep 2
            if [[ $attempt -eq 3 ]]; then
                echo "ERROR: Failed to mount BTRFS partition $BTRFS after 3 attempts"
                exit 1
            fi
        fi
    done
    
    print_info "Creating BTRFS subvolumes."
    subvols=(snapshots var_pkgs var_log home root srv)
    for subvol in '' "${subvols[@]}"; do
        btrfs su cr /mnt/@"$subvol" || {
            echo "ERROR: Failed to create subvolume @$subvol"
            exit 1
        }
    done
    
    umount /mnt
    
    print_info "Mounting the newly created subvolumes."
    # Mount root subvolume with retries
    for attempt in {1..3}; do
        if mount -o rw,noatime,compress-force=zstd:1,space_cache=v2,subvol=@ "$BTRFS" /mnt; then
            print_info "Root subvolume mounted successfully."
            break
        else
            echo "Root subvolume mount attempt $attempt failed. Retrying..."
            sleep 2
            if [[ $attempt -eq 3 ]]; then
                echo "ERROR: Failed to mount root subvolume after 3 attempts"
                exit 1
            fi
        fi
    done
    
    mkdir -p /mnt/{home,root,srv,.snapshots,var/{log,cache/pacman/pkg}}
    mount -o rw,noatime,compress-force=zstd:1,space_cache=v2,subvol=@home "$BTRFS" /mnt/home
    mount -o rw,noatime,compress-force=zstd:1,space_cache=v2,subvol=@root "$BTRFS" /mnt/root
    mount -o rw,noatime,compress-force=zstd:1,space_cache=v2,subvol=@srv "$BTRFS" /mnt/srv
    mount -o rw,noatime,compress-force=zstd:1,space_cache=v2,subvol=@snapshots "$BTRFS" /mnt/.snapshots
    mount -o rw,noatime,compress-force=zstd:1,space_cache=v2,subvol=@var_log "$BTRFS" /mnt/var/log
    mount -o rw,noatime,compress-force=zstd:1,space_cache=v2,subvol=@var_pkgs "$BTRFS" /mnt/var/cache/pacman/pkg
    
    mkdir -p /mnt/boot
    # Mount EFI partition with retries for BTRFS setup
    for attempt in {1..3}; do
        if mount "$ESP" /mnt/boot; then
            print_info "EFI partition mounted successfully to /mnt/boot."
            break
        else
            echo "EFI mount attempt $attempt failed. Retrying..."
            sleep 2
            if [[ $attempt -eq 3 ]]; then
                echo "ERROR: Failed to mount EFI partition to /mnt/boot after 3 attempts"
                exit 1
            fi
        fi
    done
    
else
    # ext4 filesystem
    print_info "Formatting the ext4 partition: $ROOT"
    # Clear any existing filesystem signatures first
    wipefs -a "$ROOT" 2>/dev/null || true
    udevadm settle
    
    # Try formatting with retries for VirtualBox compatibility
    for attempt in {1..3}; do
        if mkfs.ext4 -F "$ROOT"; then
            print_info "ext4 partition formatted successfully."
            break
        else
            echo "ext4 formatting attempt $attempt failed. Retrying..."
            sleep 2
            udevadm settle
            if [[ $attempt -eq 3 ]]; then
                echo "ERROR: Failed to format ext4 partition $ROOT after 3 attempts"
                echo "Partition info:"
                lsblk "$ROOT" 2>/dev/null || echo "Cannot get partition info"
                exit 1
            fi
        fi
    done
    
    # Mount ext4 root with retries
    print_info "Mounting ext4 partition: $ROOT"
    for attempt in {1..3}; do
        if mount "$ROOT" /mnt; then
            print_info "ext4 partition mounted successfully."
            break
        else
            echo "ext4 mount attempt $attempt failed. Retrying..."
            sleep 2
            if [[ $attempt -eq 3 ]]; then
                echo "ERROR: Failed to mount ext4 partition $ROOT after 3 attempts"
                exit 1
            fi
        fi
    done
    
    mkdir -p /mnt/boot
    # Mount EFI partition with retries for ext4 setup
    for attempt in {1..3}; do
        if mount "$ESP" /mnt/boot; then
            print_info "EFI partition mounted successfully to /mnt/boot."
            break
        else
            echo "EFI mount attempt $attempt failed. Retrying..."
            sleep 2
            if [[ $attempt -eq 3 ]]; then
                echo "ERROR: Failed to mount EFI partition to /mnt/boot after 3 attempts"
                exit 1
            fi
        fi
    done
fi

echo ""
echo "âœ“ Step 1 Complete: Disk partitioning and setup finished"
echo ""
echo "========================================"
echo "STEP 2: BASE SYSTEM INSTALLATION"
echo "========================================"

print_info "Checking for CPU type and installing ucode."
proc_type=$(lscpu)
if grep -E "GenuineIntel" <<< ${proc_type}; then
    print_info "Installing Intel microcode."
    echo "â†’ Installing intel-ucode..."
    pacstrap /mnt intel-ucode 2>&1 | while IFS= read -r line; do
        echo "  $line"
        echo "$line" >> "$LOG_FILE" 2>/dev/null || true
    done
elif grep -E "AuthenticAMD" <<< ${proc_type}; then
    print_info "Installing AMD microcode."
    echo "â†’ Installing amd-ucode..."
    pacstrap /mnt amd-ucode 2>&1 | while IFS= read -r line; do
        echo "  $line"
        echo "$line" >> "$LOG_FILE" 2>/dev/null || true
    done
fi

# Re-installing keyring because sometimes we have key problems
print_info "Installing the base system and bootloader."
echo "This may take several minutes depending on your internet connection."
echo "Note: Some warnings about system bus configuration or firmware are normal during installation."
echo ""
echo "ðŸ‰ ================================"
echo "ðŸ“¦ INSTALLING BASE SYSTEM PACKAGES"
echo "ðŸ‰ ================================"
echo "You will see real-time progress below with visual indicators:"
echo "  ðŸ“¦ = Package operations"
echo "  ðŸ” = Checking/verification"
echo "  ðŸ“¥ = Downloading"
echo "  ðŸ§© = Dependency resolution"
echo ""
log_message "INFO" "Starting base system installation with pacstrap"

# Count total packages for progress tracking
base_packages=(base base-devel "${kernel}" linux-firmware grub efibootmgr dosfstools os-prober mtools networkmanager dhcpcd git sudo)
total_packages=${#base_packages[@]}
current_package=0

echo "ï¿½ Installing ${total_packages} base system packages..."
echo "ðŸ“‹ Packages: ${base_packages[*]}"
echo ""

# Show real-time pacstrap progress with enhanced output
pacstrap -K /mnt "${base_packages[@]}" 2>&1 | while IFS= read -r line; do
    # Add visual indicators for different types of output
    if [[ "$line" =~ ^.*error.*$ ]] || [[ "$line" =~ ^.*failed.*$ ]]; then
        echo "âŒ $line"
    elif [[ "$line" =~ ^.*warning.*$ ]]; then
        echo "âš ï¸  $line" 
    elif [[ "$line" =~ installing.* ]] || [[ "$line" =~ upgrading.* ]]; then
        echo "ðŸ“¦ $line"
    elif [[ "$line" =~ checking.* ]]; then
        echo "ðŸ” $line"
    elif [[ "$line" =~ loading.* ]]; then
        echo "ðŸ“¥ $line"
    elif [[ "$line" =~ resolving.* ]]; then
        echo "ðŸ§© $line"
    elif [[ "$line" =~ \[.*\] ]]; then
        echo "ðŸ“‹ $line"
    else
        echo "ï¿½ $line"
    fi
    
    echo "$line" >> "$LOG_FILE" 2>/dev/null || true
done

echo ""
echo "âœ… Base system installation completed successfully!"
echo "ðŸ“Š Installed ${total_packages} packages: ${base_packages[*]}"
echo ""
log_message "SUCCESS" "Base system installation completed"

if [[ "$fs_type" = "btrfs" ]]; then
    print_info "Installing important btrfs-related packages."
    echo "Installing: btrfs-progs snapper"
    pacstrap /mnt btrfs-progs snapper 2>&1 | while IFS= read -r line; do
        echo "$line"
        echo "$line" >> "$LOG_FILE" 2>/dev/null || true
    done
    echo "âœ“ Btrfs packages installed successfully!"
fi

if [[ "$kyos_desktop" = "yes" ]]; then
    print_info "Installing KyOS Qtile desktop packages."
    echo "Installing desktop environment packages. This may show some warnings which are normal."
    log_message "INFO" "Starting KyOS desktop installation"
    
    # Setup chaotic-aur repository first
    print_info "Setting up chaotic-aur repository for AUR packages."
    print_info "Retrieving the primary key to enable installation of keyring and mirrorlist..."
    echo ""
    echo "================================"
    echo "SETTING UP CHAOTIC-AUR REPOSITORY"
    echo "================================"
    
    # Step 1: Get the primary key
    echo "â†’ Retrieving chaotic-aur primary key..."
    arch-chroot /mnt pacman-key --recv-key 3056513887B78AEB --keyserver keyserver.ubuntu.com 2>&1 | while IFS= read -r line; do
        echo "  $line"
    done || {
        echo "â†’ Trying alternative keyserver..."
        arch-chroot /mnt pacman-key --recv-key 3056513887B78AEB --keyserver keys.gnupg.net 2>&1 | while IFS= read -r line; do
            echo "  $line"
        done || {
            echo "â†’ Trying another keyserver..."
            arch-chroot /mnt pacman-key --recv-key 3056513887B78AEB --keyserver pgp.mit.edu 2>&1 | while IFS= read -r line; do
                echo "  $line"
            done || {
                print_info "Warning: Could not retrieve chaotic-aur key. Skipping chaotic-aur setup."
                return 0
            }
        }
    }
    
    # Step 2: Locally sign the key
    echo "â†’ Locally signing the chaotic-aur key..."
    arch-chroot /mnt pacman-key --lsign-key 3056513887B78AEB 2>&1 | while IFS= read -r line; do
        echo "  $line"
    done
    
    # Step 3: Install keyring and mirrorlist packages
    echo "â†’ Installing chaotic-keyring package..."
    arch-chroot /mnt pacman -U --noconfirm 'https://cdn-mirror.chaotic.cx/chaotic-aur/chaotic-keyring.pkg.tar.zst' 2>&1 | while IFS= read -r line; do
        echo "  $line"
    done || {
        echo "â†’ Trying alternative mirror for keyring..."
        arch-chroot /mnt pacman -U --noconfirm 'https://mirror.chaotic.cx/chaotic-aur/chaotic-keyring.pkg.tar.zst' 2>&1 | while IFS= read -r line; do
            echo "  $line"
        done || {
            print_info "Warning: Could not install chaotic-keyring. Skipping chaotic-aur setup."
            return 0
        }
    }
    
    echo "â†’ Installing chaotic-mirrorlist package..."
    arch-chroot /mnt pacman -U --noconfirm 'https://cdn-mirror.chaotic.cx/chaotic-aur/chaotic-mirrorlist.pkg.tar.zst' 2>&1 | while IFS= read -r line; do
        echo "  $line"
    done || {
        echo "â†’ Trying alternative mirror for mirrorlist..."
        arch-chroot /mnt pacman -U --noconfirm 'https://mirror.chaotic.cx/chaotic-aur/chaotic-mirrorlist.pkg.tar.zst' 2>&1 | while IFS= read -r line; do
            echo "  $line"
        done || {
            print_info "Warning: Could not install chaotic-mirrorlist. Skipping chaotic-aur setup."
            return 0
        }
    }
    
    # Copy the complete pacman.conf from live environment to target system
    print_info "Configuring pacman.conf with all repositories."
    cp /etc/pacman.conf /mnt/etc/pacman.conf
    
    # Configure pacman.conf with custom repositories
    print_info "Configuring pacman.conf with all repositories."
    
    # Start with a clean pacman.conf and add our repositories
    # First copy the basic structure
    cp /etc/pacman.conf /mnt/etc/pacman.conf
    
    # Ensure dtos-core-repo is present
    if ! grep -q "\[dtos-core-repo\]" /mnt/etc/pacman.conf; then
        print_info "Adding dtos-core-repo to pacman.conf"
        cat >> /mnt/etc/pacman.conf << 'EOF'

[dtos-core-repo]
SigLevel = Optional DatabaseOptional
Server = https://gitlab.com/dtos/$repo/-/raw/main/$arch
EOF
    fi
    
    # Add chaotic-aur repository
    print_info "Adding chaotic-aur repository to pacman.conf"
    if ! grep -q "\[chaotic-aur\]" /mnt/etc/pacman.conf; then
        cat >> /mnt/etc/pacman.conf << 'EOF'

[chaotic-aur]
Include = /etc/pacman.d/chaotic-mirrorlist
EOF
    fi
    
    # Copy mirrorlist files
    cp /etc/pacman.d/mirrorlist /mnt/etc/pacman.d/mirrorlist
    cp /etc/pacman.d/chaotic-mirrorlist /mnt/etc/pacman.d/chaotic-mirrorlist 2>/dev/null || true
    
    # Update package databases with full system update
    echo ""
    echo "================================"
    echo "UPDATING PACKAGE DATABASES"
    echo "================================"
    print_info "Running full system update and syncing mirrorlist..."
    echo "â†’ Synchronizing package databases and updating system..."
    if ! arch-chroot /mnt pacman -Syu --noconfirm 2>&1 | while IFS= read -r line; do
        echo "  $line"
        echo "$line" >> "$LOG_FILE" 2>/dev/null || true
    done; then
        echo "â†’ Full system update failed, trying basic sync..."
        if ! arch-chroot /mnt pacman -Sy --noconfirm 2>&1 | while IFS= read -r line; do
            echo "  $line"
            echo "$line" >> "$LOG_FILE" 2>/dev/null || true
        done; then
            print_info "Warning: Failed to update package databases. Some packages may not be available."
            print_info "Continuing with official repositories only..."
            
            # Remove problematic repositories if sync fails
            sed -i '/\[chaotic-aur\]/,/^$/d' /mnt/etc/pacman.conf
            sed -i '/\[dtos-core-repo\]/,/^$/d' /mnt/etc/pacman.conf
            arch-chroot /mnt pacman -Sy --noconfirm 2>&1 | while IFS= read -r line; do
                echo "  $line"
            done
        fi
    else
        print_info "âœ“ Chaotic-AUR repository successfully configured and synchronized!"
    fi
    
    # Install Pipewire audio system first to avoid conflicts
    echo ""
    echo "================================"
    echo "INSTALLING AUDIO SYSTEM"
    echo "================================"
    print_info "Setting up Pipewire audio system."
    echo "â†’ Installing Pipewire core packages..."
    arch-chroot /mnt pacman -S --noconfirm --needed pipewire pipewire-alsa pipewire-pulse wireplumber pulsemixer 2>&1 | while IFS= read -r line; do
        echo "  $line"
        echo "$line" >> "$LOG_FILE" 2>/dev/null || true
    done
    
    # Install pipewire-jack separately with conflict resolution
    echo "â†’ Installing pipewire-jack (JACK compatibility)..."
    if ! arch-chroot /mnt pacman -S --noconfirm --needed pipewire-jack 2>&1 | while IFS= read -r line; do
        echo "  $line"
        echo "$line" >> "$LOG_FILE" 2>/dev/null || true
    done; then
        echo "â†’ Resolving jack2 conflict..."
        arch-chroot /mnt pacman -Rdd jack2 --noconfirm 2>/dev/null || true
        arch-chroot /mnt pacman -S --noconfirm --needed pipewire-jack --overwrite '*' 2>&1 | while IFS= read -r line; do
            echo "  $line"
            echo "$line" >> "$LOG_FILE" 2>/dev/null || true
        done
    fi
    echo "âœ“ Audio system installation completed!"
    
    # Now install remaining packages
    echo ""
    echo "================================"
    echo "INSTALLING DESKTOP PACKAGES"
    echo "================================"
    print_info "Installing remaining desktop packages."
    echo "This may take 10-30 minutes depending on your internet connection."
    echo ""
    failed_packages=()
    package_count=0
    
    # Count total packages first
    total_packages=$(grep -v '^#' /root/pkgs-qtile | grep -v '^$' | wc -l)
    echo "ðŸ“¦ DESKTOP PACKAGE INSTALLATION PROGRESS"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "Total packages to install: $total_packages"
    echo ""
    
    while IFS= read -r line; do
        if [[ ! "$line" =~ ^#.* ]] && [[ -n "$line" ]]; then
            # Skip Pipewire packages we already installed
            if [[ "$line" =~ ^(pipewire|pipewire-alsa|pipewire-pulse|pipewire-jack|wireplumber|pulsemixer)$ ]]; then
                continue
            fi
            
            package_count=$((package_count + 1))
            
            # Use enhanced installation function for better visibility
            if ! install_package_with_progress "$line" "$package_count" "$total_packages" "$line"; then
                echo "  âš ï¸  Package '$line' failed to install, attempting conflict resolution..."
                
                # Try removing jack2 if it conflicts
                arch-chroot /mnt pacman -Rdd jack2 --noconfirm 2>/dev/null || true
                
                # Try installing again with overwrite
                echo "  ðŸ”„ Retrying installation with conflict resolution..."
                if ! arch-chroot /mnt pacman -S --noconfirm --needed "$line" --overwrite '*' 2>&1 | while IFS= read -r output_line; do
                    echo "    $output_line"
                    echo "$output_line" >> "$LOG_FILE" 2>/dev/null || true
                done; then
                    echo "  âŒ FINAL FAILURE: Package '$line' could not be installed"
                    failed_packages+=("$line")
                    continue
                fi
                echo "  âœ… Successfully installed '$line' after conflict resolution"
            fi
            
            # Show progress percentage
            percentage=$((package_count * 100 / total_packages))
            echo "ðŸš€ Progress: $percentage% ($package_count/$total_packages packages completed)"
            echo ""
        fi
    done < /root/pkgs-qtile
    
    # Report failed packages
    if [[ ${#failed_packages[@]} -gt 0 ]]; then
        print_info "The following packages failed to install:"
        for pkg in "${failed_packages[@]}"; do
            echo "  - $pkg"
        done
        print_info "These packages can be installed manually after booting into the new system."
        print_info "Try: sudo pacman -S <package-name>"
        
        # Create a script to install failed packages
        cat > /mnt/home/"$username"/install-missing-packages.sh << 'EOF'
#!/bin/bash
# Script to install packages that failed during KyOS installation

echo "Installing missing KyOS packages..."
echo "You may need to set up chaotic-aur repository first if not already configured."

failed_packages=(
EOF
        for pkg in "${failed_packages[@]}"; do
            echo "    \"$pkg\"" >> /mnt/home/"$username"/install-missing-packages.sh
        done
        
        cat >> /mnt/home/"$username"/install-missing-packages.sh << 'EOF'
)

for package in "${failed_packages[@]}"; do
    echo "Installing $package..."
    sudo pacman -S --noconfirm --needed "$package" || echo "Failed to install $package"
done

echo "Installation of missing packages completed."
EOF
        
        chmod +x /mnt/home/"$username"/install-missing-packages.sh
        arch-chroot /mnt chown "$username:$username" /home/"$username"/install-missing-packages.sh
        print_info "Created /home/$username/install-missing-packages.sh for manual installation of failed packages."
    fi
fi

# Install BlackArch support if requested
log_message "DEBUG" "BlackArch support check: blackarch_support='$blackarch_support'"
if [ "$blackarch_support" = "yes" ]; then
    print_info "Setting up BlackArch repository access."
    log_message "INFO" "Installing BlackArch repository and tools"
    install_blackarch
else
    log_message "INFO" "BlackArch support disabled - skipping BlackArch installation"
fi

# Install NVIDIA drivers if requested
if [ "$nvidia_support" = "yes" ]; then
    print_info "Setting up NVIDIA drivers and utilities."
    
    # Run graphics detection first (disable exit on error for this check)
    set +e
    detect_graphics
    gpu_type=$?
    set -e
    
    if [ $gpu_type -eq 0 ]; then
        print_info "NVIDIA GPU confirmed - proceeding with driver installation."
        install_nvidia_drivers
    else
        print_info "No NVIDIA GPU detected (detected type: $gpu_type). Skipping NVIDIA driver installation."
    fi
fi

# Setup swap based on user selection
case "$swap_type" in
    "zram")
        print_info "Setting up ZRAM compressed swap."
        setup_zram
        ;;
    "partition")
        print_info "Setting up traditional swap."
        setup_swap_partition
        ;;
    "none")
        print_info "No swap will be configured."
        ;;
    *)
        print_info "Unknown swap type '$swap_type', defaulting to ZRAM."
        setup_zram
        ;;
esac

echo ""
echo "âœ“ Step 3 Complete: Desktop environment installation finished"
echo ""
echo "========================================"
echo "STEP 4: SYSTEM CONFIGURATION"
echo "========================================"

print_info "Generating fstab."
echo "â†’ Creating filesystem table..."
genfstab -U /mnt >> /mnt/etc/fstab

print_info "Setting the hostname as $hostname."
echo "â†’ Configuring hostname..."
echo "$hostname" > /mnt/etc/hostname

print_info "Setting up localization."
echo "â†’ Configuring network hosts..."
echo "127.0.0.1   localhost
::1         localhost
127.0.1.1   $hostname.localdomain   $hostname" > /mnt/etc/hosts

print_info "Configuring selected locale and keymap."
echo "â†’ Setting up locale ($locale) and keymap ($keymap)..."
sed -i "/^#$locale/s/^#//" /mnt/etc/locale.gen
echo "LANG=$locale" > /mnt/etc/locale.conf
echo "KEYMAP=$keymap" > /mnt/etc/vconsole.conf

print_info "Setting timezone to $timezone."
arch-chroot /mnt ln -sf /usr/share/zoneinfo/"$timezone" /etc/localtime &>/dev/null
arch-chroot /mnt hwclock --systohc

print_info "Configuring users and passwords."
arch-chroot /mnt useradd -m -G wheel,audio,video,optical,storage -s /bin/zsh "$username"
echo "$username:$userpass" | arch-chroot /mnt chpasswd
echo "root:$rootpass" | arch-chroot /mnt chpasswd

print_info "Setting up sudo configuration."
# Ensure sudo is properly configured for wheel group
echo "%wheel ALL=(ALL:ALL) ALL" > /mnt/etc/sudoers.d/wheel-sudo

# Also setup doas as alternative
echo "permit persist :wheel" > /mnt/etc/doas.conf

echo ""
echo "âœ“ Step 4 Complete: System configuration finished"
echo ""
echo "========================================"
echo "STEP 5: BOOTLOADER INSTALLATION"
echo "========================================"

# Installation in chroot
disk_var="$disk"
username_var="$username"
kyos_desktop_var="$kyos_desktop"
firmware_var="$firmware_type"

arch-chroot /mnt /bin/bash <<EOF
    set -e  # Enable error checking after entering the environment
    
    echo "â†’ Generating locales..."
    locale-gen
    
    echo "â†’ Installing GRUB bootloader..."
    echo "Firmware type: $firmware_var"
    echo "Target disk: $disk_var"
    
    if [[ "$firmware_var" = "UEFI" ]]; then
        echo "â†’ Installing GRUB for UEFI system..."
        grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB --debug || {
            echo "â†’ GRUB UEFI installation failed, trying alternative method..."
            grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB --removable --debug
        }
        echo "âœ“ GRUB UEFI installation completed"
    else
        echo "â†’ Installing GRUB for BIOS system..."
        echo "Using disk: $disk_var"
        grub-install --target=i386-pc --debug $disk_var || {
            echo "ERROR: GRUB BIOS installation failed!"
            echo "Checking if BIOS boot partition exists..."
            parted $disk_var print
            exit 1
        }
        echo "âœ“ GRUB BIOS installation completed"
    fi
    
    echo "â†’ Generating GRUB configuration..."
    grub-mkconfig -o /boot/grub/grub.cfg || {
        echo "ERROR: GRUB configuration generation failed!"
        exit 1
    }
    echo "âœ“ GRUB configuration generated successfully"
    
    if [[ "$kyos_desktop_var" = "yes" ]]; then
        echo "Installing alacritty themes."
        mkdir -p /home/"$username_var"/.config/alacritty/themes
        if command -v git >/dev/null 2>&1; then
            git clone https://github.com/alacritty/alacritty-theme /home/"$username_var"/.config/alacritty/themes 2>/dev/null || echo "Warning: Could not clone alacritty themes (git failed)"
        else
            echo "Warning: git not available, skipping alacritty themes"
        fi
        chown -R "$username_var":"$username_var" /home/"$username_var"/.config
    fi
    
    echo ""
    echo "âœ“ Step 5 Complete: Bootloader installation finished"
    echo ""
    echo "========================================"
    echo "STEP 6: FINAL SETUP AND SERVICES"
    echo "========================================"
    
    echo "â†’ Enabling essential services..."
    
    if [[ "$kyos_desktop_var" = "yes" ]]; then
        # Enable services one by one with error handling - desktop installation
        systemctl enable NetworkManager 2>/dev/null && echo "âœ“ Enabled NetworkManager" || echo "âš  NetworkManager not found"
        systemctl enable bluetooth.service 2>/dev/null && echo "âœ“ Enabled bluetooth" || echo "âš  Bluetooth not found" 
        systemctl enable cups.service 2>/dev/null && echo "âœ“ Enabled CUPS printing" || echo "âš  CUPS not found"
        systemctl enable sddm.service 2>/dev/null && echo "âœ“ Enabled SDDM display manager" || echo "âš  SDDM not found"
        systemctl enable systemd-oomd.service 2>/dev/null && echo "âœ“ Enabled systemd-oomd" || echo "âš  systemd-oomd not found"
        systemctl enable reflector.timer 2>/dev/null && echo "âœ“ Enabled reflector timer" || echo "âš  Reflector not found"
        systemctl enable udisks2.service 2>/dev/null && echo "âœ“ Enabled udisks2" || echo "âš  udisks2 not found"
        systemctl enable avahi-daemon.service 2>/dev/null && echo "âœ“ Enabled avahi-daemon" || echo "âš  Avahi not found"
    else
        # Enable services for minimal installation
        systemctl enable reflector.timer 2>/dev/null && echo "âœ“ Enabled reflector timer" || echo "âš  Reflector not found"
        systemctl enable sddm.service 2>/dev/null && echo "âœ“ Enabled SDDM display manager" || echo "âš  SDDM not found"
        systemctl enable systemd-oomd.service 2>/dev/null && echo "âœ“ Enabled systemd-oomd" || echo "âš  systemd-oomd not found"
        systemctl enable udisks2.service 2>/dev/null && echo "âœ“ Enabled udisks2" || echo "âš  udisks2 not found"
    fi
    
    echo "â†’ Configuring sudo and doas..."
    # Keep sudo and also setup doas
    # Don't remove sudo as many KyOS scripts may depend on it
    echo "Both sudo and doas are available for administrative tasks."
EOF

# Copy configuration files and setup KyOS environment
if [[ "$kyos_desktop" = "yes" ]]; then
    print_info "Setting up KyOS configuration files."
    
    # Create necessary directories
    mkdir -p /mnt/home/"$username"/.local/share/fonts/
    mkdir -p /mnt/home/"$username"/.config
    
    # Copy skeleton files from live environment
    if [[ -d /run/archiso/airootfs/etc/skel ]]; then
        rsync -avr /run/archiso/airootfs/etc/skel/ /mnt/home/"$username"/ || echo "Warning: Could not copy skeleton files"
    fi
    
    # Copy KyOS configuration if it exists
    if [[ -d /mnt/etc/dtos ]]; then
        rsync -avr /mnt/etc/dtos/ /mnt/home/"$username"/ || echo "Warning: Could not copy DTOS config from /etc/dtos"
    fi
    
    # The KyOS packages should have installed their configs, but let's ensure user ownership
    # KyOS packages typically install configs to /etc/skel or user directories during package installation
    
    print_info "KyOS configuration files installed via packages."
fi

# Check if we are in a VM and install VM tools
vm_check

# Set proper permissions and finalize KyOS setup
print_info "Setting up file permissions and finalizing KyOS configuration."
arch-chroot /mnt chown -R "$username:$username" /home/"$username"

if [[ "$kyos_desktop" = "yes" ]]; then
    # Set executable permissions for important KyOS scripts
    arch-chroot /mnt chmod 755 /home/"$username"/.config/qtile/autostart.sh 2>/dev/null || echo "Warning: Could not set qtile autostart permissions"
    arch-chroot /mnt chmod 755 /home/"$username"/.local/bin/* 2>/dev/null || echo "Warning: Could not set local bin permissions"
    
    # Ensure fish shell is properly configured
    arch-chroot /mnt chsh -s /usr/bin/fish "$username" || echo "Warning: Could not set fish as default shell"
    
    # Install custom SDDM theme
    print_info "Installing custom SDDM theme."
    
    # Copy SDDM configuration files to the installed system
    if [[ -f /run/archiso/airootfs/etc/sddm.conf.installer-only ]]; then
        cp /run/archiso/airootfs/etc/sddm.conf.installer-only /mnt/etc/sddm.conf
        print_info "âœ“ SDDM configuration installed"
    fi
    
    if [[ -d /run/archiso/airootfs/etc/sddm.conf.d.installer-only ]]; then
        cp -r /run/archiso/airootfs/etc/sddm.conf.d.installer-only /mnt/etc/sddm.conf.d
        print_info "âœ“ SDDM theme configuration installed"
    fi
    
    # Copy SDDM theme installer and assets to the installed system
    if [[ -f /run/archiso/airootfs/usr/local/bin/install-sddm-theme ]]; then
        cp /run/archiso/airootfs/usr/local/bin/install-sddm-theme /mnt/usr/local/bin/ || echo "Warning: Could not copy SDDM theme installer"
        chmod +x /mnt/usr/local/bin/install-sddm-theme || echo "Warning: Could not set SDDM theme installer permissions"
    fi
    
    # Copy SDDM theme assets
    if [[ -d /run/archiso/airootfs/usr/local/share/kyos-assets ]]; then
        mkdir -p /mnt/usr/local/share/
        rsync -avr /run/archiso/airootfs/usr/local/share/kyos-assets/ /mnt/usr/local/share/kyos-assets/ || echo "Warning: Could not copy KyOS assets"
    fi
    
    # Run the SDDM theme installer
    if [[ -f /mnt/usr/local/bin/install-sddm-theme ]]; then
        arch-chroot /mnt /usr/local/bin/install-sddm-theme || echo "Warning: SDDM theme installation failed"
    else
        echo "Warning: SDDM theme installer not found"
    fi
    
    # Install KyOS dotfiles from GitHub repository
    print_info "Installing KyOS dotfiles and configurations..."
    arch-chroot /mnt /bin/bash -c "
        # Create temporary directory for dotfiles
        temp_dir=\$(mktemp -d)
        cd \"\$temp_dir\" || exit 1
        
        # Clone the KyOS dotfiles repository
        if command -v git >/dev/null 2>&1; then
            print_info 'Downloading KyOS dotfiles from GitHub...'
            if git clone --depth 1 https://github.com/rubberpirate/ky-suigetsu.git . 2>/dev/null; then
                if [[ -d 'Dots' ]]; then
                    print_info 'Installing KyOS dotfiles to user home directory...'
                    
                    # Copy all dotfiles and configs to user home directory
                    # Use rsync to handle hidden files and preserve permissions
                    rsync -avr --exclude='.git' Dots/ /home/$username/ 2>/dev/null || {
                        # Fallback to cp if rsync fails
                        cp -r Dots/. /home/$username/ 2>/dev/null || echo 'Warning: Could not copy some dotfiles'
                    }
                    
                    # Ensure proper ownership of all copied files
                    chown -R $username:$username /home/$username/
                    
                    # Set proper permissions for config directories
                    chmod 755 /home/$username/.config 2>/dev/null || true
                    chmod 755 /home/$username/.local 2>/dev/null || true
                    chmod 755 /home/$username/.local/bin 2>/dev/null || true
                    chmod +x /home/$username/.local/bin/* 2>/dev/null || true
                    
                    print_info 'âœ“ KyOS dotfiles installed successfully!'
                    print_info 'User configurations and customizations are now ready.'
                else
                    echo 'Warning: Dots folder not found in repository'
                fi
            else
                echo 'Warning: Failed to clone KyOS dotfiles repository'
                echo 'You can manually install dotfiles later with:'
                echo 'git clone https://github.com/rubberpirate/ky-suigetsu.git && cp -r ky-suigetsu/Dots/. ~/'
            fi
        else
            echo 'Warning: git not available for dotfiles installation'
            echo 'Install git and clone dotfiles manually after first boot'
        fi
        
        # Cleanup temporary directory
        cd / && rm -rf \"\$temp_dir\" 2>/dev/null || true
    " || echo "Warning: Dotfiles installation encountered errors"
    
    # Check for VM environment and apply VM-specific configurations
    print_info "Checking for virtual machine environment..."
    
    # Detect VM environment
    hypervisor=$(systemd-detect-virt 2>/dev/null || echo "none")
    is_vm=false
    
    case $hypervisor in
        kvm|qemu|vmware|oracle|microsoft|xen|parallels)
            is_vm=true
            print_info "Virtual machine detected: $hypervisor"
            ;;
        *)
            print_info "Physical hardware or unknown environment detected"
            ;;
    esac
    
    # Ask user if they want VM optimizations (even if not detected, for edge cases)
    if [[ "$is_vm" == "true" ]]; then
        print_info "Applying VM-specific optimizations automatically..."
        apply_vm_config=true
    else
        # Ask user manually if they're running in a VM
        print_info "Are you installing KyOS in a virtual machine?"
        echo "This will apply VM-specific optimizations and configurations."
        echo "Press 'y' for Yes, 'n' for No, or wait 10 seconds for auto-detection result..."
        
        apply_vm_config=false
        if read -t 10 -n 1 -r vm_response; then
            echo
            case $vm_response in
                [Yy]*)
                    apply_vm_config=true
                    print_info "User confirmed VM environment - applying VM configurations"
                    ;;
                *)
                    print_info "Skipping VM-specific configurations"
                    ;;
            esac
        else
            echo
            print_info "No response received - using auto-detection result"
        fi
    fi
    
    # Apply VM-specific configurations if requested
    if [[ "$apply_vm_config" == "true" ]]; then
        print_info "Installing VM-specific configurations..."
        arch-chroot /mnt /bin/bash -c "
            # Create temporary directory for VM configs
            vm_temp_dir=\$(mktemp -d)
            cd \"\$vm_temp_dir\" || exit 1
            
            # Clone repository again for VM configs
            if command -v git >/dev/null 2>&1; then
                if git clone --depth 1 https://github.com/rubberpirate/ky-suigetsu.git . 2>/dev/null; then
                    if [[ -d 'only for vm' ]]; then
                        print_info 'Applying VM-specific dotfiles and configurations...'
                        
                        # Copy VM-specific configs to .config directory
                        if [[ -d '/home/$username/.config' ]]; then
                            # Use rsync to merge VM configs with existing configs
                            rsync -avr --exclude='.git' 'only for vm/' /home/$username/.config/ 2>/dev/null || {
                                # Fallback to cp if rsync fails
                                cp -r 'only for vm/.' /home/$username/.config/ 2>/dev/null || echo 'Warning: Could not copy some VM configs'
                            }
                        else
                            # Create .config directory if it doesn't exist
                            mkdir -p /home/$username/.config
                            rsync -avr --exclude='.git' 'only for vm/' /home/$username/.config/ 2>/dev/null || {
                                cp -r 'only for vm/.' /home/$username/.config/ 2>/dev/null || echo 'Warning: Could not copy some VM configs'
                            }
                        fi
                        
                        # Ensure proper ownership of VM configs
                        chown -R $username:$username /home/$username/.config/
                        
                        # Set proper permissions for VM config files
                        chmod 755 /home/$username/.config 2>/dev/null || true
                        find /home/$username/.config -type d -exec chmod 755 {} \; 2>/dev/null || true
                        find /home/$username/.config -type f -exec chmod 644 {} \; 2>/dev/null || true
                        
                        print_info 'âœ“ VM-specific configurations applied successfully!'
                        print_info 'Your KyOS installation is now optimized for virtual machines.'
                    else
                        echo 'Warning: VM configuration folder not found in repository'
                    fi
                else
                    echo 'Warning: Failed to clone repository for VM configurations'
                fi
            else
                echo 'Warning: git not available for VM configuration installation'
            fi
            
            # Cleanup VM temp directory
            cd / && rm -rf \"\$vm_temp_dir\" 2>/dev/null || true
        " || echo "Warning: VM configuration installation encountered errors"
    fi
    
    # ...existing code...
fi

print_info "Installation of KyOS completed! You may now reboot the computer."

# Verify installation
print_info "Verifying installation..."
echo "Checking user groups:"
arch-chroot /mnt groups "$username" || echo "Warning: Could not check user groups"

echo "Checking sudo configuration:"
if [[ -f /mnt/etc/sudoers.d/wheel-sudo ]]; then
    echo "âœ“ Sudo configured for wheel group"
else
    echo "âœ— Sudo configuration may be missing"
fi

echo "Checking if user is in wheel group:"
if arch-chroot /mnt groups "$username" | grep -q wheel; then
    echo "âœ“ User $username is in wheel group"
else
    echo "âœ— User $username is NOT in wheel group"
fi
        
print_info "KyOS automated installation finished successfully!"
log_message "SUCCESS" "KyOS automated installation completed successfully"

# Create final installation report
report_file=$(create_install_report)

echo "========================================"
echo "Installation Summary:"
echo "- Hostname: $hostname"
echo "- Username: $username"
echo "- Password: $userpass"
echo "- Root password: $rootpass"
echo "- Filesystem: $fs_type (no encryption)"
echo "- Desktop: KyOS Qtile"
echo "- BlackArch repository: $blackarch_support"
echo "- NVIDIA support: $nvidia_support"
echo "- Swap type: $swap_type"
echo "========================================"
echo "Installation logs and report saved:"
echo "- Main Log: $LOG_FILE"
if [ -f "$ERROR_LOG" ] && [ -s "$ERROR_LOG" ]; then
    echo "- Error Log: $ERROR_LOG (âš  Errors found)"
fi
echo "- Report: $report_file"
if [ -d "/mnt/var/log/kyos-install" ]; then
    echo "- Installed System: /var/log/kyos-install/"
fi
echo "========================================"
echo "You can now reboot your system with: reboot"

log_message "INFO" "KyOS Automated Installation System exiting"

exit
